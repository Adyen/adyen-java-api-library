/*
 * Adyen Checkout API
 *
 * The version of the OpenAPI document: 71
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.adyen.model.checkout;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.adyen.model.checkout.AchDetails;
import com.adyen.model.checkout.AfterpayDetails;
import com.adyen.model.checkout.AmazonPayDetails;
import com.adyen.model.checkout.AncvDetails;
import com.adyen.model.checkout.AndroidPayDetails;
import com.adyen.model.checkout.ApplePayDetails;
import com.adyen.model.checkout.BacsDirectDebitDetails;
import com.adyen.model.checkout.BillDeskDetails;
import com.adyen.model.checkout.BlikDetails;
import com.adyen.model.checkout.CardDetails;
import com.adyen.model.checkout.CellulantDetails;
import com.adyen.model.checkout.DokuDetails;
import com.adyen.model.checkout.DotpayDetails;
import com.adyen.model.checkout.DragonpayDetails;
import com.adyen.model.checkout.EcontextVoucherDetails;
import com.adyen.model.checkout.GenericIssuerPaymentMethodDetails;
import com.adyen.model.checkout.GiropayDetails;
import com.adyen.model.checkout.GooglePayDetails;
import com.adyen.model.checkout.IdealDetails;
import com.adyen.model.checkout.KlarnaDetails;
import com.adyen.model.checkout.MasterpassDetails;
import com.adyen.model.checkout.MbwayDetails;
import com.adyen.model.checkout.MobilePayDetails;
import com.adyen.model.checkout.MolPayDetails;
import com.adyen.model.checkout.OpenInvoiceDetails;
import com.adyen.model.checkout.PayPalDetails;
import com.adyen.model.checkout.PayUUpiDetails;
import com.adyen.model.checkout.PayWithGoogleDetails;
import com.adyen.model.checkout.PaymentDetails;
import com.adyen.model.checkout.RatepayDetails;
import com.adyen.model.checkout.SamsungPayDetails;
import com.adyen.model.checkout.SepaDirectDebitDetails;
import com.adyen.model.checkout.StoredPaymentMethodDetails;
import com.adyen.model.checkout.UpiCollectDetails;
import com.adyen.model.checkout.UpiIntentDetails;
import com.adyen.model.checkout.VippsDetails;
import com.adyen.model.checkout.VisaCheckoutDetails;
import com.adyen.model.checkout.WeChatPayDetails;
import com.adyen.model.checkout.WeChatPayMiniProgramDetails;
import com.adyen.model.checkout.ZipDetails;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.core.type.TypeReference;

import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.Response;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;


@JsonDeserialize(using = CheckoutPaymentMethod.CheckoutPaymentMethodDeserializer.class)
@JsonSerialize(using = CheckoutPaymentMethod.CheckoutPaymentMethodSerializer.class)
public class CheckoutPaymentMethod extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(CheckoutPaymentMethod.class.getName());

    public static class CheckoutPaymentMethodSerializer extends StdSerializer<CheckoutPaymentMethod> {
        public CheckoutPaymentMethodSerializer(Class<CheckoutPaymentMethod> t) {
            super(t);
        }

        public CheckoutPaymentMethodSerializer() {
            this(null);
        }

        @Override
        public void serialize(CheckoutPaymentMethod value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class CheckoutPaymentMethodDeserializer extends StdDeserializer<CheckoutPaymentMethod> {
        public CheckoutPaymentMethodDeserializer() {
            this(CheckoutPaymentMethod.class);
        }

        public CheckoutPaymentMethodDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public CheckoutPaymentMethod deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();

            // deserialize AchDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchDetails.class.equals(Integer.class) || AchDetails.class.equals(Long.class) || AchDetails.class.equals(Float.class) || AchDetails.class.equals(Double.class) || AchDetails.class.equals(Boolean.class) || AchDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchDetails.class.equals(Integer.class) || AchDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchDetails.class.equals(Float.class) || AchDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(AchDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), AchDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchDetails'", e);
            }


            // deserialize AfterpayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AfterpayDetails.class.equals(Integer.class) || AfterpayDetails.class.equals(Long.class) || AfterpayDetails.class.equals(Float.class) || AfterpayDetails.class.equals(Double.class) || AfterpayDetails.class.equals(Boolean.class) || AfterpayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AfterpayDetails.class.equals(Integer.class) || AfterpayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AfterpayDetails.class.equals(Float.class) || AfterpayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AfterpayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AfterpayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(AfterpayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), AfterpayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AfterpayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AfterpayDetails'", e);
            }


            // deserialize AmazonPayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AmazonPayDetails.class.equals(Integer.class) || AmazonPayDetails.class.equals(Long.class) || AmazonPayDetails.class.equals(Float.class) || AmazonPayDetails.class.equals(Double.class) || AmazonPayDetails.class.equals(Boolean.class) || AmazonPayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AmazonPayDetails.class.equals(Integer.class) || AmazonPayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AmazonPayDetails.class.equals(Float.class) || AmazonPayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AmazonPayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AmazonPayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(AmazonPayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), AmazonPayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AmazonPayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AmazonPayDetails'", e);
            }


            // deserialize AncvDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AncvDetails.class.equals(Integer.class) || AncvDetails.class.equals(Long.class) || AncvDetails.class.equals(Float.class) || AncvDetails.class.equals(Double.class) || AncvDetails.class.equals(Boolean.class) || AncvDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AncvDetails.class.equals(Integer.class) || AncvDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AncvDetails.class.equals(Float.class) || AncvDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AncvDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AncvDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(AncvDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), AncvDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AncvDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AncvDetails'", e);
            }


            // deserialize AndroidPayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AndroidPayDetails.class.equals(Integer.class) || AndroidPayDetails.class.equals(Long.class) || AndroidPayDetails.class.equals(Float.class) || AndroidPayDetails.class.equals(Double.class) || AndroidPayDetails.class.equals(Boolean.class) || AndroidPayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AndroidPayDetails.class.equals(Integer.class) || AndroidPayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AndroidPayDetails.class.equals(Float.class) || AndroidPayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AndroidPayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AndroidPayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(AndroidPayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), AndroidPayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AndroidPayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AndroidPayDetails'", e);
            }


            // deserialize ApplePayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApplePayDetails.class.equals(Integer.class) || ApplePayDetails.class.equals(Long.class) || ApplePayDetails.class.equals(Float.class) || ApplePayDetails.class.equals(Double.class) || ApplePayDetails.class.equals(Boolean.class) || ApplePayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApplePayDetails.class.equals(Integer.class) || ApplePayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApplePayDetails.class.equals(Float.class) || ApplePayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApplePayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApplePayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(ApplePayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), ApplePayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApplePayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApplePayDetails'", e);
            }


            // deserialize BacsDirectDebitDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (BacsDirectDebitDetails.class.equals(Integer.class) || BacsDirectDebitDetails.class.equals(Long.class) || BacsDirectDebitDetails.class.equals(Float.class) || BacsDirectDebitDetails.class.equals(Double.class) || BacsDirectDebitDetails.class.equals(Boolean.class) || BacsDirectDebitDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((BacsDirectDebitDetails.class.equals(Integer.class) || BacsDirectDebitDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((BacsDirectDebitDetails.class.equals(Float.class) || BacsDirectDebitDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (BacsDirectDebitDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (BacsDirectDebitDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(BacsDirectDebitDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), BacsDirectDebitDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'BacsDirectDebitDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'BacsDirectDebitDetails'", e);
            }


            // deserialize BillDeskDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (BillDeskDetails.class.equals(Integer.class) || BillDeskDetails.class.equals(Long.class) || BillDeskDetails.class.equals(Float.class) || BillDeskDetails.class.equals(Double.class) || BillDeskDetails.class.equals(Boolean.class) || BillDeskDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((BillDeskDetails.class.equals(Integer.class) || BillDeskDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((BillDeskDetails.class.equals(Float.class) || BillDeskDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (BillDeskDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (BillDeskDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(BillDeskDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), BillDeskDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'BillDeskDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'BillDeskDetails'", e);
            }


            // deserialize BlikDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (BlikDetails.class.equals(Integer.class) || BlikDetails.class.equals(Long.class) || BlikDetails.class.equals(Float.class) || BlikDetails.class.equals(Double.class) || BlikDetails.class.equals(Boolean.class) || BlikDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((BlikDetails.class.equals(Integer.class) || BlikDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((BlikDetails.class.equals(Float.class) || BlikDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (BlikDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (BlikDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(BlikDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), BlikDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'BlikDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'BlikDetails'", e);
            }


            // deserialize CardDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CardDetails.class.equals(Integer.class) || CardDetails.class.equals(Long.class) || CardDetails.class.equals(Float.class) || CardDetails.class.equals(Double.class) || CardDetails.class.equals(Boolean.class) || CardDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CardDetails.class.equals(Integer.class) || CardDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CardDetails.class.equals(Float.class) || CardDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CardDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CardDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(CardDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), CardDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CardDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CardDetails'", e);
            }


            // deserialize CellulantDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CellulantDetails.class.equals(Integer.class) || CellulantDetails.class.equals(Long.class) || CellulantDetails.class.equals(Float.class) || CellulantDetails.class.equals(Double.class) || CellulantDetails.class.equals(Boolean.class) || CellulantDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CellulantDetails.class.equals(Integer.class) || CellulantDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CellulantDetails.class.equals(Float.class) || CellulantDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CellulantDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CellulantDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(CellulantDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), CellulantDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CellulantDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CellulantDetails'", e);
            }


            // deserialize DokuDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DokuDetails.class.equals(Integer.class) || DokuDetails.class.equals(Long.class) || DokuDetails.class.equals(Float.class) || DokuDetails.class.equals(Double.class) || DokuDetails.class.equals(Boolean.class) || DokuDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DokuDetails.class.equals(Integer.class) || DokuDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DokuDetails.class.equals(Float.class) || DokuDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DokuDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DokuDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(DokuDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), DokuDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DokuDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DokuDetails'", e);
            }


            // deserialize DotpayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DotpayDetails.class.equals(Integer.class) || DotpayDetails.class.equals(Long.class) || DotpayDetails.class.equals(Float.class) || DotpayDetails.class.equals(Double.class) || DotpayDetails.class.equals(Boolean.class) || DotpayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DotpayDetails.class.equals(Integer.class) || DotpayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DotpayDetails.class.equals(Float.class) || DotpayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DotpayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DotpayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(DotpayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), DotpayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DotpayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DotpayDetails'", e);
            }


            // deserialize DragonpayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DragonpayDetails.class.equals(Integer.class) || DragonpayDetails.class.equals(Long.class) || DragonpayDetails.class.equals(Float.class) || DragonpayDetails.class.equals(Double.class) || DragonpayDetails.class.equals(Boolean.class) || DragonpayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DragonpayDetails.class.equals(Integer.class) || DragonpayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DragonpayDetails.class.equals(Float.class) || DragonpayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DragonpayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DragonpayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(DragonpayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), DragonpayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DragonpayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DragonpayDetails'", e);
            }


            // deserialize EcontextVoucherDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (EcontextVoucherDetails.class.equals(Integer.class) || EcontextVoucherDetails.class.equals(Long.class) || EcontextVoucherDetails.class.equals(Float.class) || EcontextVoucherDetails.class.equals(Double.class) || EcontextVoucherDetails.class.equals(Boolean.class) || EcontextVoucherDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((EcontextVoucherDetails.class.equals(Integer.class) || EcontextVoucherDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((EcontextVoucherDetails.class.equals(Float.class) || EcontextVoucherDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (EcontextVoucherDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (EcontextVoucherDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(EcontextVoucherDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), EcontextVoucherDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'EcontextVoucherDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'EcontextVoucherDetails'", e);
            }


            // deserialize GenericIssuerPaymentMethodDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (GenericIssuerPaymentMethodDetails.class.equals(Integer.class) || GenericIssuerPaymentMethodDetails.class.equals(Long.class) || GenericIssuerPaymentMethodDetails.class.equals(Float.class) || GenericIssuerPaymentMethodDetails.class.equals(Double.class) || GenericIssuerPaymentMethodDetails.class.equals(Boolean.class) || GenericIssuerPaymentMethodDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((GenericIssuerPaymentMethodDetails.class.equals(Integer.class) || GenericIssuerPaymentMethodDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((GenericIssuerPaymentMethodDetails.class.equals(Float.class) || GenericIssuerPaymentMethodDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (GenericIssuerPaymentMethodDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (GenericIssuerPaymentMethodDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(GenericIssuerPaymentMethodDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), GenericIssuerPaymentMethodDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'GenericIssuerPaymentMethodDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'GenericIssuerPaymentMethodDetails'", e);
            }


            // deserialize GiropayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (GiropayDetails.class.equals(Integer.class) || GiropayDetails.class.equals(Long.class) || GiropayDetails.class.equals(Float.class) || GiropayDetails.class.equals(Double.class) || GiropayDetails.class.equals(Boolean.class) || GiropayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((GiropayDetails.class.equals(Integer.class) || GiropayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((GiropayDetails.class.equals(Float.class) || GiropayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (GiropayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (GiropayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(GiropayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), GiropayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'GiropayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'GiropayDetails'", e);
            }


            // deserialize GooglePayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (GooglePayDetails.class.equals(Integer.class) || GooglePayDetails.class.equals(Long.class) || GooglePayDetails.class.equals(Float.class) || GooglePayDetails.class.equals(Double.class) || GooglePayDetails.class.equals(Boolean.class) || GooglePayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((GooglePayDetails.class.equals(Integer.class) || GooglePayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((GooglePayDetails.class.equals(Float.class) || GooglePayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (GooglePayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (GooglePayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(GooglePayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), GooglePayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'GooglePayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'GooglePayDetails'", e);
            }


            // deserialize IdealDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (IdealDetails.class.equals(Integer.class) || IdealDetails.class.equals(Long.class) || IdealDetails.class.equals(Float.class) || IdealDetails.class.equals(Double.class) || IdealDetails.class.equals(Boolean.class) || IdealDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((IdealDetails.class.equals(Integer.class) || IdealDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((IdealDetails.class.equals(Float.class) || IdealDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (IdealDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (IdealDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(IdealDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), IdealDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'IdealDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'IdealDetails'", e);
            }


            // deserialize KlarnaDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (KlarnaDetails.class.equals(Integer.class) || KlarnaDetails.class.equals(Long.class) || KlarnaDetails.class.equals(Float.class) || KlarnaDetails.class.equals(Double.class) || KlarnaDetails.class.equals(Boolean.class) || KlarnaDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((KlarnaDetails.class.equals(Integer.class) || KlarnaDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((KlarnaDetails.class.equals(Float.class) || KlarnaDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (KlarnaDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (KlarnaDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(KlarnaDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), KlarnaDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'KlarnaDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'KlarnaDetails'", e);
            }


            // deserialize MasterpassDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (MasterpassDetails.class.equals(Integer.class) || MasterpassDetails.class.equals(Long.class) || MasterpassDetails.class.equals(Float.class) || MasterpassDetails.class.equals(Double.class) || MasterpassDetails.class.equals(Boolean.class) || MasterpassDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((MasterpassDetails.class.equals(Integer.class) || MasterpassDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((MasterpassDetails.class.equals(Float.class) || MasterpassDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (MasterpassDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (MasterpassDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(MasterpassDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), MasterpassDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'MasterpassDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MasterpassDetails'", e);
            }


            // deserialize MbwayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (MbwayDetails.class.equals(Integer.class) || MbwayDetails.class.equals(Long.class) || MbwayDetails.class.equals(Float.class) || MbwayDetails.class.equals(Double.class) || MbwayDetails.class.equals(Boolean.class) || MbwayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((MbwayDetails.class.equals(Integer.class) || MbwayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((MbwayDetails.class.equals(Float.class) || MbwayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (MbwayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (MbwayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(MbwayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), MbwayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'MbwayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MbwayDetails'", e);
            }


            // deserialize MobilePayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (MobilePayDetails.class.equals(Integer.class) || MobilePayDetails.class.equals(Long.class) || MobilePayDetails.class.equals(Float.class) || MobilePayDetails.class.equals(Double.class) || MobilePayDetails.class.equals(Boolean.class) || MobilePayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((MobilePayDetails.class.equals(Integer.class) || MobilePayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((MobilePayDetails.class.equals(Float.class) || MobilePayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (MobilePayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (MobilePayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(MobilePayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), MobilePayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'MobilePayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MobilePayDetails'", e);
            }


            // deserialize MolPayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (MolPayDetails.class.equals(Integer.class) || MolPayDetails.class.equals(Long.class) || MolPayDetails.class.equals(Float.class) || MolPayDetails.class.equals(Double.class) || MolPayDetails.class.equals(Boolean.class) || MolPayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((MolPayDetails.class.equals(Integer.class) || MolPayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((MolPayDetails.class.equals(Float.class) || MolPayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (MolPayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (MolPayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(MolPayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), MolPayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'MolPayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MolPayDetails'", e);
            }


            // deserialize OpenInvoiceDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (OpenInvoiceDetails.class.equals(Integer.class) || OpenInvoiceDetails.class.equals(Long.class) || OpenInvoiceDetails.class.equals(Float.class) || OpenInvoiceDetails.class.equals(Double.class) || OpenInvoiceDetails.class.equals(Boolean.class) || OpenInvoiceDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((OpenInvoiceDetails.class.equals(Integer.class) || OpenInvoiceDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((OpenInvoiceDetails.class.equals(Float.class) || OpenInvoiceDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (OpenInvoiceDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (OpenInvoiceDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(OpenInvoiceDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), OpenInvoiceDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'OpenInvoiceDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'OpenInvoiceDetails'", e);
            }


            // deserialize PayPalDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (PayPalDetails.class.equals(Integer.class) || PayPalDetails.class.equals(Long.class) || PayPalDetails.class.equals(Float.class) || PayPalDetails.class.equals(Double.class) || PayPalDetails.class.equals(Boolean.class) || PayPalDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((PayPalDetails.class.equals(Integer.class) || PayPalDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((PayPalDetails.class.equals(Float.class) || PayPalDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (PayPalDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (PayPalDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(PayPalDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), PayPalDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'PayPalDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'PayPalDetails'", e);
            }


            // deserialize PayUUpiDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (PayUUpiDetails.class.equals(Integer.class) || PayUUpiDetails.class.equals(Long.class) || PayUUpiDetails.class.equals(Float.class) || PayUUpiDetails.class.equals(Double.class) || PayUUpiDetails.class.equals(Boolean.class) || PayUUpiDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((PayUUpiDetails.class.equals(Integer.class) || PayUUpiDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((PayUUpiDetails.class.equals(Float.class) || PayUUpiDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (PayUUpiDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (PayUUpiDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(PayUUpiDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), PayUUpiDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'PayUUpiDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'PayUUpiDetails'", e);
            }


            // deserialize PayWithGoogleDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (PayWithGoogleDetails.class.equals(Integer.class) || PayWithGoogleDetails.class.equals(Long.class) || PayWithGoogleDetails.class.equals(Float.class) || PayWithGoogleDetails.class.equals(Double.class) || PayWithGoogleDetails.class.equals(Boolean.class) || PayWithGoogleDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((PayWithGoogleDetails.class.equals(Integer.class) || PayWithGoogleDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((PayWithGoogleDetails.class.equals(Float.class) || PayWithGoogleDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (PayWithGoogleDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (PayWithGoogleDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(PayWithGoogleDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), PayWithGoogleDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'PayWithGoogleDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'PayWithGoogleDetails'", e);
            }


            // deserialize PaymentDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (PaymentDetails.class.equals(Integer.class) || PaymentDetails.class.equals(Long.class) || PaymentDetails.class.equals(Float.class) || PaymentDetails.class.equals(Double.class) || PaymentDetails.class.equals(Boolean.class) || PaymentDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((PaymentDetails.class.equals(Integer.class) || PaymentDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((PaymentDetails.class.equals(Float.class) || PaymentDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (PaymentDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (PaymentDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(PaymentDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), PaymentDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'PaymentDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'PaymentDetails'", e);
            }


            // deserialize RatepayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (RatepayDetails.class.equals(Integer.class) || RatepayDetails.class.equals(Long.class) || RatepayDetails.class.equals(Float.class) || RatepayDetails.class.equals(Double.class) || RatepayDetails.class.equals(Boolean.class) || RatepayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((RatepayDetails.class.equals(Integer.class) || RatepayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((RatepayDetails.class.equals(Float.class) || RatepayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (RatepayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (RatepayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(RatepayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), RatepayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'RatepayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'RatepayDetails'", e);
            }


            // deserialize SamsungPayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SamsungPayDetails.class.equals(Integer.class) || SamsungPayDetails.class.equals(Long.class) || SamsungPayDetails.class.equals(Float.class) || SamsungPayDetails.class.equals(Double.class) || SamsungPayDetails.class.equals(Boolean.class) || SamsungPayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SamsungPayDetails.class.equals(Integer.class) || SamsungPayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SamsungPayDetails.class.equals(Float.class) || SamsungPayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SamsungPayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SamsungPayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(SamsungPayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), SamsungPayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SamsungPayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SamsungPayDetails'", e);
            }


            // deserialize SepaDirectDebitDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SepaDirectDebitDetails.class.equals(Integer.class) || SepaDirectDebitDetails.class.equals(Long.class) || SepaDirectDebitDetails.class.equals(Float.class) || SepaDirectDebitDetails.class.equals(Double.class) || SepaDirectDebitDetails.class.equals(Boolean.class) || SepaDirectDebitDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SepaDirectDebitDetails.class.equals(Integer.class) || SepaDirectDebitDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SepaDirectDebitDetails.class.equals(Float.class) || SepaDirectDebitDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SepaDirectDebitDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SepaDirectDebitDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(SepaDirectDebitDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), SepaDirectDebitDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SepaDirectDebitDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SepaDirectDebitDetails'", e);
            }


            // deserialize StoredPaymentMethodDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (StoredPaymentMethodDetails.class.equals(Integer.class) || StoredPaymentMethodDetails.class.equals(Long.class) || StoredPaymentMethodDetails.class.equals(Float.class) || StoredPaymentMethodDetails.class.equals(Double.class) || StoredPaymentMethodDetails.class.equals(Boolean.class) || StoredPaymentMethodDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((StoredPaymentMethodDetails.class.equals(Integer.class) || StoredPaymentMethodDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((StoredPaymentMethodDetails.class.equals(Float.class) || StoredPaymentMethodDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (StoredPaymentMethodDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (StoredPaymentMethodDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(StoredPaymentMethodDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), StoredPaymentMethodDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'StoredPaymentMethodDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'StoredPaymentMethodDetails'", e);
            }


            // deserialize UpiCollectDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (UpiCollectDetails.class.equals(Integer.class) || UpiCollectDetails.class.equals(Long.class) || UpiCollectDetails.class.equals(Float.class) || UpiCollectDetails.class.equals(Double.class) || UpiCollectDetails.class.equals(Boolean.class) || UpiCollectDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((UpiCollectDetails.class.equals(Integer.class) || UpiCollectDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((UpiCollectDetails.class.equals(Float.class) || UpiCollectDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (UpiCollectDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (UpiCollectDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(UpiCollectDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), UpiCollectDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'UpiCollectDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'UpiCollectDetails'", e);
            }


            // deserialize UpiIntentDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (UpiIntentDetails.class.equals(Integer.class) || UpiIntentDetails.class.equals(Long.class) || UpiIntentDetails.class.equals(Float.class) || UpiIntentDetails.class.equals(Double.class) || UpiIntentDetails.class.equals(Boolean.class) || UpiIntentDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((UpiIntentDetails.class.equals(Integer.class) || UpiIntentDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((UpiIntentDetails.class.equals(Float.class) || UpiIntentDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (UpiIntentDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (UpiIntentDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(UpiIntentDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), UpiIntentDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'UpiIntentDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'UpiIntentDetails'", e);
            }


            // deserialize VippsDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (VippsDetails.class.equals(Integer.class) || VippsDetails.class.equals(Long.class) || VippsDetails.class.equals(Float.class) || VippsDetails.class.equals(Double.class) || VippsDetails.class.equals(Boolean.class) || VippsDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((VippsDetails.class.equals(Integer.class) || VippsDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((VippsDetails.class.equals(Float.class) || VippsDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (VippsDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (VippsDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(VippsDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), VippsDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'VippsDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'VippsDetails'", e);
            }


            // deserialize VisaCheckoutDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (VisaCheckoutDetails.class.equals(Integer.class) || VisaCheckoutDetails.class.equals(Long.class) || VisaCheckoutDetails.class.equals(Float.class) || VisaCheckoutDetails.class.equals(Double.class) || VisaCheckoutDetails.class.equals(Boolean.class) || VisaCheckoutDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((VisaCheckoutDetails.class.equals(Integer.class) || VisaCheckoutDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((VisaCheckoutDetails.class.equals(Float.class) || VisaCheckoutDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (VisaCheckoutDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (VisaCheckoutDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(VisaCheckoutDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), VisaCheckoutDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'VisaCheckoutDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'VisaCheckoutDetails'", e);
            }


            // deserialize WeChatPayDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WeChatPayDetails.class.equals(Integer.class) || WeChatPayDetails.class.equals(Long.class) || WeChatPayDetails.class.equals(Float.class) || WeChatPayDetails.class.equals(Double.class) || WeChatPayDetails.class.equals(Boolean.class) || WeChatPayDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WeChatPayDetails.class.equals(Integer.class) || WeChatPayDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WeChatPayDetails.class.equals(Float.class) || WeChatPayDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WeChatPayDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WeChatPayDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(WeChatPayDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), WeChatPayDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WeChatPayDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WeChatPayDetails'", e);
            }


            // deserialize WeChatPayMiniProgramDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WeChatPayMiniProgramDetails.class.equals(Integer.class) || WeChatPayMiniProgramDetails.class.equals(Long.class) || WeChatPayMiniProgramDetails.class.equals(Float.class) || WeChatPayMiniProgramDetails.class.equals(Double.class) || WeChatPayMiniProgramDetails.class.equals(Boolean.class) || WeChatPayMiniProgramDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WeChatPayMiniProgramDetails.class.equals(Integer.class) || WeChatPayMiniProgramDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WeChatPayMiniProgramDetails.class.equals(Float.class) || WeChatPayMiniProgramDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WeChatPayMiniProgramDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WeChatPayMiniProgramDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(WeChatPayMiniProgramDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), WeChatPayMiniProgramDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WeChatPayMiniProgramDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WeChatPayMiniProgramDetails'", e);
            }


            // deserialize ZipDetails
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ZipDetails.class.equals(Integer.class) || ZipDetails.class.equals(Long.class) || ZipDetails.class.equals(Float.class) || ZipDetails.class.equals(Double.class) || ZipDetails.class.equals(Boolean.class) || ZipDetails.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ZipDetails.class.equals(Integer.class) || ZipDetails.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ZipDetails.class.equals(Float.class) || ZipDetails.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ZipDetails.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ZipDetails.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                // Checks if the unique type of the oneOf json matches any of the object TypeEnum values
                boolean typeMatch = Arrays.stream(ZipDetails.TypeEnum.values()).anyMatch((t) -> t.getValue().contains(tree.findValue("type").asText()));
                if (attemptParsing || typeMatch) {
                    // Strict deserialization for oneOf models
                    deserialized = JSON.getMapper().readValue(tree.toString(), ZipDetails.class);
                    // typeMatch should enforce proper deserialization
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ZipDetails'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ZipDetails'", e);
            }

            // Throw error if there is no match
            if (match == 0) {
                throw new IOException(String.format("Failed deserialization for CheckoutPaymentMethod: %d classes match result, expected 1", match));
            }
            // Log warning if there is more than one match
            if (match > 1) {
                log.log(Level.WARNING, String.format("Warning, indecisive deserialization for CheckoutPaymentMethod: %d classes match result, expected 1", match));
            }

            CheckoutPaymentMethod ret = new CheckoutPaymentMethod();
            ret.setActualInstance(deserialized);
            return ret;
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public CheckoutPaymentMethod getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "CheckoutPaymentMethod cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public CheckoutPaymentMethod() {
        super("oneOf", Boolean.FALSE);
    }

    public CheckoutPaymentMethod(AchDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(AfterpayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(AmazonPayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(AncvDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(AndroidPayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(ApplePayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(BacsDirectDebitDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(BillDeskDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(BlikDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(CardDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(CellulantDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(DokuDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(DotpayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(DragonpayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(EcontextVoucherDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(GenericIssuerPaymentMethodDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(GiropayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(GooglePayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(IdealDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(KlarnaDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(MasterpassDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(MbwayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(MobilePayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(MolPayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(OpenInvoiceDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(PayPalDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(PayUUpiDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(PayWithGoogleDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(PaymentDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(RatepayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(SamsungPayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(SepaDirectDebitDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(StoredPaymentMethodDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(UpiCollectDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(UpiIntentDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(VippsDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(VisaCheckoutDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(WeChatPayDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(WeChatPayMiniProgramDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CheckoutPaymentMethod(ZipDetails o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AchDetails", new GenericType<AchDetails>() {
        });
        schemas.put("AfterpayDetails", new GenericType<AfterpayDetails>() {
        });
        schemas.put("AmazonPayDetails", new GenericType<AmazonPayDetails>() {
        });
        schemas.put("AncvDetails", new GenericType<AncvDetails>() {
        });
        schemas.put("AndroidPayDetails", new GenericType<AndroidPayDetails>() {
        });
        schemas.put("ApplePayDetails", new GenericType<ApplePayDetails>() {
        });
        schemas.put("BacsDirectDebitDetails", new GenericType<BacsDirectDebitDetails>() {
        });
        schemas.put("BillDeskDetails", new GenericType<BillDeskDetails>() {
        });
        schemas.put("BlikDetails", new GenericType<BlikDetails>() {
        });
        schemas.put("CardDetails", new GenericType<CardDetails>() {
        });
        schemas.put("CellulantDetails", new GenericType<CellulantDetails>() {
        });
        schemas.put("DokuDetails", new GenericType<DokuDetails>() {
        });
        schemas.put("DotpayDetails", new GenericType<DotpayDetails>() {
        });
        schemas.put("DragonpayDetails", new GenericType<DragonpayDetails>() {
        });
        schemas.put("EcontextVoucherDetails", new GenericType<EcontextVoucherDetails>() {
        });
        schemas.put("GenericIssuerPaymentMethodDetails", new GenericType<GenericIssuerPaymentMethodDetails>() {
        });
        schemas.put("GiropayDetails", new GenericType<GiropayDetails>() {
        });
        schemas.put("GooglePayDetails", new GenericType<GooglePayDetails>() {
        });
        schemas.put("IdealDetails", new GenericType<IdealDetails>() {
        });
        schemas.put("KlarnaDetails", new GenericType<KlarnaDetails>() {
        });
        schemas.put("MasterpassDetails", new GenericType<MasterpassDetails>() {
        });
        schemas.put("MbwayDetails", new GenericType<MbwayDetails>() {
        });
        schemas.put("MobilePayDetails", new GenericType<MobilePayDetails>() {
        });
        schemas.put("MolPayDetails", new GenericType<MolPayDetails>() {
        });
        schemas.put("OpenInvoiceDetails", new GenericType<OpenInvoiceDetails>() {
        });
        schemas.put("PayPalDetails", new GenericType<PayPalDetails>() {
        });
        schemas.put("PayUUpiDetails", new GenericType<PayUUpiDetails>() {
        });
        schemas.put("PayWithGoogleDetails", new GenericType<PayWithGoogleDetails>() {
        });
        schemas.put("PaymentDetails", new GenericType<PaymentDetails>() {
        });
        schemas.put("RatepayDetails", new GenericType<RatepayDetails>() {
        });
        schemas.put("SamsungPayDetails", new GenericType<SamsungPayDetails>() {
        });
        schemas.put("SepaDirectDebitDetails", new GenericType<SepaDirectDebitDetails>() {
        });
        schemas.put("StoredPaymentMethodDetails", new GenericType<StoredPaymentMethodDetails>() {
        });
        schemas.put("UpiCollectDetails", new GenericType<UpiCollectDetails>() {
        });
        schemas.put("UpiIntentDetails", new GenericType<UpiIntentDetails>() {
        });
        schemas.put("VippsDetails", new GenericType<VippsDetails>() {
        });
        schemas.put("VisaCheckoutDetails", new GenericType<VisaCheckoutDetails>() {
        });
        schemas.put("WeChatPayDetails", new GenericType<WeChatPayDetails>() {
        });
        schemas.put("WeChatPayMiniProgramDetails", new GenericType<WeChatPayMiniProgramDetails>() {
        });
        schemas.put("ZipDetails", new GenericType<ZipDetails>() {
        });
        JSON.registerDescendants(CheckoutPaymentMethod.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return CheckoutPaymentMethod.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AchDetails, AfterpayDetails, AmazonPayDetails, AncvDetails, AndroidPayDetails, ApplePayDetails, BacsDirectDebitDetails, BillDeskDetails, BlikDetails, CardDetails, CellulantDetails, DokuDetails, DotpayDetails, DragonpayDetails, EcontextVoucherDetails, GenericIssuerPaymentMethodDetails, GiropayDetails, GooglePayDetails, IdealDetails, KlarnaDetails, MasterpassDetails, MbwayDetails, MobilePayDetails, MolPayDetails, OpenInvoiceDetails, PayPalDetails, PayUUpiDetails, PayWithGoogleDetails, PaymentDetails, RatepayDetails, SamsungPayDetails, SepaDirectDebitDetails, StoredPaymentMethodDetails, UpiCollectDetails, UpiIntentDetails, VippsDetails, VisaCheckoutDetails, WeChatPayDetails, WeChatPayMiniProgramDetails, ZipDetails
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(AchDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AfterpayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AmazonPayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AncvDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AndroidPayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApplePayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(BacsDirectDebitDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(BillDeskDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(BlikDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CardDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CellulantDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DokuDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DotpayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DragonpayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EcontextVoucherDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(GenericIssuerPaymentMethodDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(GiropayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(GooglePayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(IdealDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(KlarnaDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(MasterpassDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(MbwayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(MobilePayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(MolPayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(OpenInvoiceDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(PayPalDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(PayUUpiDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(PayWithGoogleDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(PaymentDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(RatepayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SamsungPayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SepaDirectDebitDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(StoredPaymentMethodDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(UpiCollectDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(UpiIntentDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(VippsDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(VisaCheckoutDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WeChatPayDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WeChatPayMiniProgramDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ZipDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AchDetails, AfterpayDetails, AmazonPayDetails, AncvDetails, AndroidPayDetails, ApplePayDetails, BacsDirectDebitDetails, BillDeskDetails, BlikDetails, CardDetails, CellulantDetails, DokuDetails, DotpayDetails, DragonpayDetails, EcontextVoucherDetails, GenericIssuerPaymentMethodDetails, GiropayDetails, GooglePayDetails, IdealDetails, KlarnaDetails, MasterpassDetails, MbwayDetails, MobilePayDetails, MolPayDetails, OpenInvoiceDetails, PayPalDetails, PayUUpiDetails, PayWithGoogleDetails, PaymentDetails, RatepayDetails, SamsungPayDetails, SepaDirectDebitDetails, StoredPaymentMethodDetails, UpiCollectDetails, UpiIntentDetails, VippsDetails, VisaCheckoutDetails, WeChatPayDetails, WeChatPayMiniProgramDetails, ZipDetails");
    }

    /**
     * Get the actual instance, which can be the following:
     * AchDetails, AfterpayDetails, AmazonPayDetails, AncvDetails, AndroidPayDetails, ApplePayDetails, BacsDirectDebitDetails, BillDeskDetails, BlikDetails, CardDetails, CellulantDetails, DokuDetails, DotpayDetails, DragonpayDetails, EcontextVoucherDetails, GenericIssuerPaymentMethodDetails, GiropayDetails, GooglePayDetails, IdealDetails, KlarnaDetails, MasterpassDetails, MbwayDetails, MobilePayDetails, MolPayDetails, OpenInvoiceDetails, PayPalDetails, PayUUpiDetails, PayWithGoogleDetails, PaymentDetails, RatepayDetails, SamsungPayDetails, SepaDirectDebitDetails, StoredPaymentMethodDetails, UpiCollectDetails, UpiIntentDetails, VippsDetails, VisaCheckoutDetails, WeChatPayDetails, WeChatPayMiniProgramDetails, ZipDetails
     *
     * @return The actual instance (AchDetails, AfterpayDetails, AmazonPayDetails, AncvDetails, AndroidPayDetails, ApplePayDetails, BacsDirectDebitDetails, BillDeskDetails, BlikDetails, CardDetails, CellulantDetails, DokuDetails, DotpayDetails, DragonpayDetails, EcontextVoucherDetails, GenericIssuerPaymentMethodDetails, GiropayDetails, GooglePayDetails, IdealDetails, KlarnaDetails, MasterpassDetails, MbwayDetails, MobilePayDetails, MolPayDetails, OpenInvoiceDetails, PayPalDetails, PayUUpiDetails, PayWithGoogleDetails, PaymentDetails, RatepayDetails, SamsungPayDetails, SepaDirectDebitDetails, StoredPaymentMethodDetails, UpiCollectDetails, UpiIntentDetails, VippsDetails, VisaCheckoutDetails, WeChatPayDetails, WeChatPayMiniProgramDetails, ZipDetails)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchDetails`. If the actual instance is not `AchDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchDetails`
     * @throws ClassCastException if the instance is not `AchDetails`
     */
    public AchDetails getAchDetails() throws ClassCastException {
        return (AchDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AfterpayDetails`. If the actual instance is not `AfterpayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AfterpayDetails`
     * @throws ClassCastException if the instance is not `AfterpayDetails`
     */
    public AfterpayDetails getAfterpayDetails() throws ClassCastException {
        return (AfterpayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AmazonPayDetails`. If the actual instance is not `AmazonPayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AmazonPayDetails`
     * @throws ClassCastException if the instance is not `AmazonPayDetails`
     */
    public AmazonPayDetails getAmazonPayDetails() throws ClassCastException {
        return (AmazonPayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AncvDetails`. If the actual instance is not `AncvDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AncvDetails`
     * @throws ClassCastException if the instance is not `AncvDetails`
     */
    public AncvDetails getAncvDetails() throws ClassCastException {
        return (AncvDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AndroidPayDetails`. If the actual instance is not `AndroidPayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AndroidPayDetails`
     * @throws ClassCastException if the instance is not `AndroidPayDetails`
     */
    public AndroidPayDetails getAndroidPayDetails() throws ClassCastException {
        return (AndroidPayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApplePayDetails`. If the actual instance is not `ApplePayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApplePayDetails`
     * @throws ClassCastException if the instance is not `ApplePayDetails`
     */
    public ApplePayDetails getApplePayDetails() throws ClassCastException {
        return (ApplePayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `BacsDirectDebitDetails`. If the actual instance is not `BacsDirectDebitDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BacsDirectDebitDetails`
     * @throws ClassCastException if the instance is not `BacsDirectDebitDetails`
     */
    public BacsDirectDebitDetails getBacsDirectDebitDetails() throws ClassCastException {
        return (BacsDirectDebitDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `BillDeskDetails`. If the actual instance is not `BillDeskDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BillDeskDetails`
     * @throws ClassCastException if the instance is not `BillDeskDetails`
     */
    public BillDeskDetails getBillDeskDetails() throws ClassCastException {
        return (BillDeskDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `BlikDetails`. If the actual instance is not `BlikDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BlikDetails`
     * @throws ClassCastException if the instance is not `BlikDetails`
     */
    public BlikDetails getBlikDetails() throws ClassCastException {
        return (BlikDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CardDetails`. If the actual instance is not `CardDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CardDetails`
     * @throws ClassCastException if the instance is not `CardDetails`
     */
    public CardDetails getCardDetails() throws ClassCastException {
        return (CardDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CellulantDetails`. If the actual instance is not `CellulantDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CellulantDetails`
     * @throws ClassCastException if the instance is not `CellulantDetails`
     */
    public CellulantDetails getCellulantDetails() throws ClassCastException {
        return (CellulantDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DokuDetails`. If the actual instance is not `DokuDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DokuDetails`
     * @throws ClassCastException if the instance is not `DokuDetails`
     */
    public DokuDetails getDokuDetails() throws ClassCastException {
        return (DokuDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DotpayDetails`. If the actual instance is not `DotpayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DotpayDetails`
     * @throws ClassCastException if the instance is not `DotpayDetails`
     */
    public DotpayDetails getDotpayDetails() throws ClassCastException {
        return (DotpayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DragonpayDetails`. If the actual instance is not `DragonpayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DragonpayDetails`
     * @throws ClassCastException if the instance is not `DragonpayDetails`
     */
    public DragonpayDetails getDragonpayDetails() throws ClassCastException {
        return (DragonpayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `EcontextVoucherDetails`. If the actual instance is not `EcontextVoucherDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EcontextVoucherDetails`
     * @throws ClassCastException if the instance is not `EcontextVoucherDetails`
     */
    public EcontextVoucherDetails getEcontextVoucherDetails() throws ClassCastException {
        return (EcontextVoucherDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `GenericIssuerPaymentMethodDetails`. If the actual instance is not `GenericIssuerPaymentMethodDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `GenericIssuerPaymentMethodDetails`
     * @throws ClassCastException if the instance is not `GenericIssuerPaymentMethodDetails`
     */
    public GenericIssuerPaymentMethodDetails getGenericIssuerPaymentMethodDetails() throws ClassCastException {
        return (GenericIssuerPaymentMethodDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `GiropayDetails`. If the actual instance is not `GiropayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `GiropayDetails`
     * @throws ClassCastException if the instance is not `GiropayDetails`
     */
    public GiropayDetails getGiropayDetails() throws ClassCastException {
        return (GiropayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `GooglePayDetails`. If the actual instance is not `GooglePayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `GooglePayDetails`
     * @throws ClassCastException if the instance is not `GooglePayDetails`
     */
    public GooglePayDetails getGooglePayDetails() throws ClassCastException {
        return (GooglePayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `IdealDetails`. If the actual instance is not `IdealDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IdealDetails`
     * @throws ClassCastException if the instance is not `IdealDetails`
     */
    public IdealDetails getIdealDetails() throws ClassCastException {
        return (IdealDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `KlarnaDetails`. If the actual instance is not `KlarnaDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `KlarnaDetails`
     * @throws ClassCastException if the instance is not `KlarnaDetails`
     */
    public KlarnaDetails getKlarnaDetails() throws ClassCastException {
        return (KlarnaDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MasterpassDetails`. If the actual instance is not `MasterpassDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MasterpassDetails`
     * @throws ClassCastException if the instance is not `MasterpassDetails`
     */
    public MasterpassDetails getMasterpassDetails() throws ClassCastException {
        return (MasterpassDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MbwayDetails`. If the actual instance is not `MbwayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MbwayDetails`
     * @throws ClassCastException if the instance is not `MbwayDetails`
     */
    public MbwayDetails getMbwayDetails() throws ClassCastException {
        return (MbwayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MobilePayDetails`. If the actual instance is not `MobilePayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MobilePayDetails`
     * @throws ClassCastException if the instance is not `MobilePayDetails`
     */
    public MobilePayDetails getMobilePayDetails() throws ClassCastException {
        return (MobilePayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MolPayDetails`. If the actual instance is not `MolPayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MolPayDetails`
     * @throws ClassCastException if the instance is not `MolPayDetails`
     */
    public MolPayDetails getMolPayDetails() throws ClassCastException {
        return (MolPayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `OpenInvoiceDetails`. If the actual instance is not `OpenInvoiceDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `OpenInvoiceDetails`
     * @throws ClassCastException if the instance is not `OpenInvoiceDetails`
     */
    public OpenInvoiceDetails getOpenInvoiceDetails() throws ClassCastException {
        return (OpenInvoiceDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `PayPalDetails`. If the actual instance is not `PayPalDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PayPalDetails`
     * @throws ClassCastException if the instance is not `PayPalDetails`
     */
    public PayPalDetails getPayPalDetails() throws ClassCastException {
        return (PayPalDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `PayUUpiDetails`. If the actual instance is not `PayUUpiDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PayUUpiDetails`
     * @throws ClassCastException if the instance is not `PayUUpiDetails`
     */
    public PayUUpiDetails getPayUUpiDetails() throws ClassCastException {
        return (PayUUpiDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `PayWithGoogleDetails`. If the actual instance is not `PayWithGoogleDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PayWithGoogleDetails`
     * @throws ClassCastException if the instance is not `PayWithGoogleDetails`
     */
    public PayWithGoogleDetails getPayWithGoogleDetails() throws ClassCastException {
        return (PayWithGoogleDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `PaymentDetails`. If the actual instance is not `PaymentDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentDetails`
     * @throws ClassCastException if the instance is not `PaymentDetails`
     */
    public PaymentDetails getPaymentDetails() throws ClassCastException {
        return (PaymentDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RatepayDetails`. If the actual instance is not `RatepayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RatepayDetails`
     * @throws ClassCastException if the instance is not `RatepayDetails`
     */
    public RatepayDetails getRatepayDetails() throws ClassCastException {
        return (RatepayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SamsungPayDetails`. If the actual instance is not `SamsungPayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SamsungPayDetails`
     * @throws ClassCastException if the instance is not `SamsungPayDetails`
     */
    public SamsungPayDetails getSamsungPayDetails() throws ClassCastException {
        return (SamsungPayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SepaDirectDebitDetails`. If the actual instance is not `SepaDirectDebitDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SepaDirectDebitDetails`
     * @throws ClassCastException if the instance is not `SepaDirectDebitDetails`
     */
    public SepaDirectDebitDetails getSepaDirectDebitDetails() throws ClassCastException {
        return (SepaDirectDebitDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `StoredPaymentMethodDetails`. If the actual instance is not `StoredPaymentMethodDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `StoredPaymentMethodDetails`
     * @throws ClassCastException if the instance is not `StoredPaymentMethodDetails`
     */
    public StoredPaymentMethodDetails getStoredPaymentMethodDetails() throws ClassCastException {
        return (StoredPaymentMethodDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `UpiCollectDetails`. If the actual instance is not `UpiCollectDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UpiCollectDetails`
     * @throws ClassCastException if the instance is not `UpiCollectDetails`
     */
    public UpiCollectDetails getUpiCollectDetails() throws ClassCastException {
        return (UpiCollectDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `UpiIntentDetails`. If the actual instance is not `UpiIntentDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UpiIntentDetails`
     * @throws ClassCastException if the instance is not `UpiIntentDetails`
     */
    public UpiIntentDetails getUpiIntentDetails() throws ClassCastException {
        return (UpiIntentDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `VippsDetails`. If the actual instance is not `VippsDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `VippsDetails`
     * @throws ClassCastException if the instance is not `VippsDetails`
     */
    public VippsDetails getVippsDetails() throws ClassCastException {
        return (VippsDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `VisaCheckoutDetails`. If the actual instance is not `VisaCheckoutDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `VisaCheckoutDetails`
     * @throws ClassCastException if the instance is not `VisaCheckoutDetails`
     */
    public VisaCheckoutDetails getVisaCheckoutDetails() throws ClassCastException {
        return (VisaCheckoutDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WeChatPayDetails`. If the actual instance is not `WeChatPayDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WeChatPayDetails`
     * @throws ClassCastException if the instance is not `WeChatPayDetails`
     */
    public WeChatPayDetails getWeChatPayDetails() throws ClassCastException {
        return (WeChatPayDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WeChatPayMiniProgramDetails`. If the actual instance is not `WeChatPayMiniProgramDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WeChatPayMiniProgramDetails`
     * @throws ClassCastException if the instance is not `WeChatPayMiniProgramDetails`
     */
    public WeChatPayMiniProgramDetails getWeChatPayMiniProgramDetails() throws ClassCastException {
        return (WeChatPayMiniProgramDetails)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ZipDetails`. If the actual instance is not `ZipDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ZipDetails`
     * @throws ClassCastException if the instance is not `ZipDetails`
     */
    public ZipDetails getZipDetails() throws ClassCastException {
        return (ZipDetails)super.getActualInstance();
    }

    /**
    * Create an instance of CheckoutPaymentMethod given an JSON string
    *
    * @param jsonString JSON string
    * @return An instance of CheckoutPaymentMethod
    * @throws IOException if the JSON string is invalid with respect to CheckoutPaymentMethod
    */
    public static CheckoutPaymentMethod fromJson(String jsonString) throws IOException {
        return JSON.getMapper().readValue(jsonString, CheckoutPaymentMethod.class);
    }

    /**
    * Convert an instance of CheckoutPaymentMethod to an JSON string
    *
    * @return JSON string
    */
    public String toJson() throws JsonProcessingException {
        return JSON.getMapper().writeValueAsString(this);
    }
}

